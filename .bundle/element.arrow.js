var u=(o=>(o.Animation="--animating",o.Collapsed="--collapsed",o.Defined="--defined",o.Disabled="--disabled",o.Expanded="--expanded",o.Interactive="--interactive",o.Loaded="--loaded",o.Scrolled="--scrolled",o))(u||{}),a=u;function k(t){let{$template:e,template:i,delegatesFocus:l=!1,mode:n="closed",serializable:r=!1}=t,s=this.attachShadow({delegatesFocus:l,mode:n,serializable:r});return e instanceof DocumentFragment&&s.appendChild(e.cloneNode(!0)),typeof i=="string"&&s.setHTMLUnsafe(i),s}var y=k;var d=["bottom","bottom-left","bottom-right","left","right","top","top-left","top-right"],c=["angle-left-top","angle-right-bottom","angle-right-bottom-fill","angle-right-top","angle-thick-bottom-left","angle-thick-bottom-right-fill","angle-thick-left-bottom-line","angle-thick-top-left","angle-thick-top-right","fill","line"],h=["acute","angled","large","large-acute","large-angled","large-oblique","oblique"],g=["thick"],f=(t,e)=>{if(e===null||!e?.cssRules)return!0;for(let i of e.cssRules)if(i.selectorText===`[data-glyph="${t}"]`)return!0;return!1},m=t=>d.includes(t),w=t=>c.includes(t),b=t=>h.includes(t),S=t=>g.includes(t);var v=`<link id="link-styling" fetchpriority="low" href="http://assets.protosite.xyz/core/element.arrow.css" media="screen" rel="stylesheet" type="text/css" title="Visual Rules for Arrow Element"/><link id="link-glyph-collection" fetchpriority="low" href="http://assets.protosite.xyz/uikit/element/icon.glyphs-arrow.css" media="screen" rel="stylesheet" type="text/css" title="Visual Symbol defines by the glyph name that passed to the data attribute"/><style type="text/css">:host(:state(--defined)) {
	content-visibility: hidden;
}
:host(:state(--loaded)) {
	content-visibility: visible;
}</style><div class="icon" id="icon-container" data-glyph="arrow" role="presentation"></div><slot></slot>`;var p=class t extends HTMLElement{#l=this.attachInternals();#e;#t;static observedAttributes=["glyph-direction","glyph-figure","glyph-style","glyph-weight"];static role="img";static tagName="e-arrow";static directions=d;static figures=c;static styles=h;static weights=g;constructor(){super(),this.#e=y.call(this,{template:v}),this.#i.add(a.Defined)}attributeChangedCallback(e,i,l){i!==l&&this.#o()}connectedCallback(){this.setAttribute("role",t.role),this.#n.onload=({currentTarget:e})=>{this.#t=e.sheet,this.#i.add(a.Loaded)}}#o(){let e=["arrow"],[i,l,n,r]=["glyph-direction","glyph-figure","glyph-style","glyph-weight"].map(x=>this.getAttribute(x));if(r!==null)if(S(r))e.push(r);else throw new TypeError(`Invalid Weight: ${r}`);if(i!==null)if(m(i))e.push(i);else throw new TypeError(`Invalid Direction: ${i}`);if(l!==null)if(w(l))e.push(l);else throw new TypeError(`Invalid Figure: ${l}`);if(n!==null)if(b(n))e.push(n);else throw new TypeError(`Invalid Style: ${n}`);let s=e.join("-");console.assert(f(s,this.#t),`Unsupported Glyph: ${s}`),this.#s.dataset.glyph=s}get#s(){return this.#e.getElementById("icon-container")}get#n(){return this.#e.getElementById("link-styling")}get#i(){return this.#l.states}},I=p;export{I as default};
